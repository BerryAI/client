<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="shared-styles.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">

<dom-module id="my-sample-view">
    <template>
        <style include="shared-styles">
            :host {
                display: block;

                padding: 10px;
            }
        </style>

        <div class="card">
            <paper-input id="ipfs_id" label="ipfs id"></paper-input>
            <paper-button raised on-tap="goOnline">Start IPFS</paper-button>
            <paper-button raised on-tap="playWav">Play .wav</paper-button>
            <paper-button raised on-tap="stopPlaying">Stop</paper-button>

            <p></p>
            <paper-input id="file" label="file" type="file"></paper-input>
            <paper-button raised on-tap="loadIntoIPFS">Load</paper-button>
            <p>hash: {{hash}}</p>

            <p>status: {{status}}</p>
            <p>My coinbase is {{coinbase}}
            <p>My balance is {{balance}}</p>
        </div>
    </template>

    <script>
        var horseMp3 = "QmeVPhqpAhJcdeP6CSFi75GHRFY8HHh7k5Vsn5fAg5SajZ";
        var sampleWav = "QmNpsNioVxMAVGrPwZ5wpLqTbzqUyh54pomATGaoG6eNWH";
        var danMp3 = "QmZjCB1LVp5khCaMqDrCRsyPo26xKTbsh3xE1ytoBiDz4N";
        var danWav = "QmazhzHSygTY48LkVs7EmDkApkje8N9M3EUL8NttmPwGkz";

        window.AudioContext = window.AudioContext || window.webkitAudioContext;

        var IPFS = require('ipfs')
        var Web3 = require('web3');
        var fs = require('fs');
        var currentContext;

        var ipfs = new IPFS();
        var web3 = new Web3();

        web3.setProvider(new web3.providers.HttpProvider('http://localhost:8545'));

        Polymer({
            is: 'my-sample-view',
            playWav: function() {
                var id = this.$.ipfs_id.value;
                this.status = "Loading " + id;
                playFile(this, id);
            },
            stopPlaying: function() {
                if (currentContext) {
                    currentContext.close();
                    this.status = "Stopped";
                } else {
                    this.status = "Er ... stop what?";
                }
            },
            loadIntoIPFS: function() {
                loadFileIntoIPFS(this, this.$.file.value);
            },
            goOnline : function() {
                connectToIPFS(this);
            },
            ready: function() {
                this.coinbase = web3.eth.coinbase;
                this.balance = web3.eth.getBalance(web3.eth.coinbase);
                // text: QmdoThKrthF85h9McUKvKsi4X5m5g2AKu66GfVyM9FvvnC
//                var mp3 = "QmeVPhqpAhJcdeP6CSFi75GHRFY8HHh7k5Vsn5fAg5SajZ";
            }
        });

        function loadFileIntoIPFS(caller, path) {
            caller.status = "Loading " + path + "...";
            var result = ipfs.files.add(fs.createReadStream(path));
            console.log(result);
        }

        function connectToIPFS(caller) {
            caller.status = "Connecting ...";
            ipfs.goOnline(function(err){
                if (err) {
                    caller.status = "Failed to connect";
                    throw err;
                }
                caller.status = ipfs.isOnline() ? "Connected!" : "Failed to connect (no error thrown)";
            });
        }

        function playFile(caller, id) {
            if (currentContext) {
                currentContext.close();
            }
            currentContext = new AudioContext();
            caller.status = "Loading from ipfs...";
            ipfs.files.cat(id, function(err, file) {
                if (err) {
                    caller.status = err;
                    throw err;
                }
                const chunks = [];
                file.on("data", function (chunk) {
                    caller.status = "Receiving chunks...";
                    chunks.push(chunk);
                });
                // Send the buffer or you can put it into a var
                file.on("end", function () {
                    caller.status = "Decoding...";
                    currentContext.decodeAudioData(toArrayBuffer(Buffer.concat(chunks)),
                        function(decoded) {
                            caller.status = "Playing...";
                            playSound(currentContext, decoded);
                        },
                        function(err) {
                            caller.status = "Decoded failed: Err: " + err;
                            console.log("Failed!  " + err);
                        }
                    );
                });
            });
        }

        function playSound(context, buffer) {
            console.log("Playing sound...");
            var source = context.createBufferSource(); // creates a sound source
            source.buffer = buffer;                    // tell the source which sound to play
            source.connect(context.destination);       // connect the source to the context's destination (the speakers)
            source.start(0);                           // play the source now
                                                       // note: on older systems, may have to use deprecated noteOn(time);
        }

        function toArrayBuffer(buf) {
            // I'm sure there is a better way to do this...
            var ab = new ArrayBuffer(buf.length);
            var view = new Uint8Array(ab);
            for (var i = 0; i < buf.length; ++i) {
                view[i] = buf[i];
            }
            return ab;

            // var b = buf;
            // var ab = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
            // return new Uint32Array(b.buffer, b.byteOffset, b.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        }
    </script>
</dom-module>
